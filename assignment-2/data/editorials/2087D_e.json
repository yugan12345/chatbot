{
    "Problem Id": "2087D",
    "Tutorial": "Note that if the order of words was determined, we could solve it using a regular binary search, that needs \u2308log2n\u2309 queries (we will return to this later). In other words, for n\u2264500, we will need no more than 9 queries. This means we have one query to spare. So let's ask about the first position. If we receive a handle that starts with an uppercase letter, then either uppercase letters come before lowercase letters, or there are no handles that start with a lowercase letter at all. In both cases, we can say that uppercase letters are less than lowercase letters. If, however, we receive a handle that starts with a lowercase letter, we can similarly conclude that lowercase letters are less than uppercase letters. Now, having spent one query, we have determined the relative order of the letters and can proceed to search for the desired handle using binary search. To do this, let's maintain a semi-interval of the list [l,r), about which we know that the handle h is definitely located within it (in other words, we know that handle[l]\u2264h and h<handle[r]). Initially, we start with the entire list [1,n+1). Now, as long as the length of the semi-interval [l,r) is greater than 1, we still do not know exactly where our handle is located. Therefore, let's choose the midpoint of this interval m=r\u2212l2 and make a query at position m. If handle[m]\u2264h, we can definitively say that our handle lies in the semi-interval [m,r). Otherwise, if h<handle[m], then the handle lies in the interval [l,m). As soon as the length of the segment becomes 1, we will know the exact position of the handle. Since after each query the length of the semi-interval n becomes \u2308n2\u2309 in the worst case, we will need no more than \u2308log2n\u2309 queries to reduce the segment to a length of 1. To compare the responses to queries with the handle h, it is convenient to write a special function that compares them, taking into account whether lowercase letters come before uppercase letters or vice versa. P.S.: Binary search can also be written in \u230Alog2n\u230B, but this was not required in the problem.",
    "Solution/Code":"import kotlin.system.exitProcess\n\nfun main() {\n    val (nString, h) = readln().split(\" \")\n\n    fun ask(pos: Int): String {\n        println(\"? ${pos + 1}\")\n        System.out.flush()\n        val resp = readln()\n        if (resp == \"-1\")\n            exitProcess(0)\n        return resp\n    }\n\n    fun isLower(s: String) = s[0].isLowerCase()\n\n    val lowerCaseFirst = isLower(ask(0))\n    fun lowerOrEqual(a: String, b: String) : Boolean {\n        if (isLower(a) == isLower(b))\n            return a <= b;\n        return isLower(a) == lowerCaseFirst\n    }\n    var l = 0\n    var r = nString.toInt()\n    while (r - l > 1) {\n        val mid = (l + r) / 2\n        if (lowerOrEqual(ask(mid), h))\n            l = mid\n        else\n            r = mid\n    }\n    println(\"! ${l + 1}\")\n}"

}