{
    "Problem Id": "2087F",
    "Tutorial": "The problem can be solved using dynamic programming. Let dps,i,j represent the minimum damage Monocarp can get if the current stage is s, physical damage is i, and elemental damage is j. To make transitions, we need to calculate two values: the number of alive monsters and check if there is at least one alive monster that can be killed. Note that i and j also show the number of killed monsters, which is i+j\u22122. Therefore, the number of alive monsters is equal to min(s,n)\u2212(i+j\u22122), which is the number of spawned monsters minus the number of killed ones. Additionally, we can maintain an array cnti,j that stores the number of spawned monsters that can be killed with i physical damage and j elemental damage, including those that have already been killed. Updating this array is easy. When the s-th monster appears, we should increase cnti,j by 1 for all i\u2265as or j\u2265bs. Note that all monsters that were killed early can also be killed now. This means that all the killed monsters are included in cnti,j. Therefore, the number of alive monsters that can be killed is equal to cnti,j\u2212(i+j\u22122). It is also important to note that the number of stages can be up to 2n\u22121. This solution works in O(n\u00b3). If you store all values of dynamic programming, you will probably get ML, so you should maintain only two \"layers\" of dynamic programming: for the previous value of s and for the current value of s.",
    "Solution/Code":"const val N = 505\nconst val INF = 1e9.toInt()\n\nfun main() {\n  val n = readln().toInt()\n  val a = readln().split(\" \").map { it.toInt() - 1}\n  val b = readln().split(\" \").map { it.toInt() - 1}\n  \n  val cnt = Array(N) { IntArray(N) { 0 } }\n  val dp = Array(2) { Array(N) { IntArray(N) { INF } } }\n  dp[0][0][0] = 0\n\n  for (t in 0 until 2 * n) {\n    val ct = t and 1\n    val nt = ct xor 1\n    \n    if (t < n) {\n      for (i in 0 until N) for (j in 0 until N) {\n        if (a[t] <= i || b[t] <= j) ++cnt[i][j];\n      } \n    }\n\n    dp[nt].forEach { it.fill(INF) }\n    for (i in 0 until N) for (j in 0 until N) {\n      if (dp[ct][i][j] != INF) {\n        val lft = minOf(t + 1, n) - i - j\n        if (cnt[i][j] > i + j) {\n          dp[nt][i + 1][j] = minOf(dp[nt][i + 1][j], dp[ct][i][j] + lft - 1)\n          dp[nt][i][j + 1] = minOf(dp[nt][i][j + 1], dp[ct][i][j] + lft - 1)\n        } else {\n          if (t < n || lft == 0) dp[nt][i][j] = minOf(dp[nt][i][j], dp[ct][i][j] + lft)\n        }\n      }\n    }\n  }\n\n  var ans = INF\n  for (i in 0 until N) for (j in 0 until N) ans = minOf(ans, dp[0][i][j])\n  if (ans == INF) ans = -1\n  println(ans)\n}"

}