{
    "Problem Id": "2087I",
    "Tutorial": "Each Hamiltonian cycle will contain some edges from the original graph and some added edges. Let's first understand when a certain set of edges can be part of a Hamiltonian cycle.\n\nFirstly, there should not be a pair of edges that enter or exit the same vertex. Secondly, there should not be cycles that do not include all vertices. In fact, these two requirements are sufficient — if they are met, all vertices of the graph are divided into separate paths that can be easily glued together into a Hamiltonian cycle.\n\nThis means that the edges of the given graph need to be divided into the minimum number of groups such that each group has at most one incoming/outgoing edge from each vertex, and there are no cycles (except for those which go through all vertices). However, the original graph is acyclic, so the second requirement is actually impossible to violate.\n\nIf we \"split\" the vertices by creating two parts and replacing each directed edge (x,y) with an edge between vertex x in the left part and vertex y in the right part, then the requirement of \"at most one incoming/outgoing edge from each vertex in each group\" transforms into \"no vertex is incident to more than one edge\". This means that a group is a matching in a bipartite graph.\n\nNow our task is to divide this bipartite graph into the minimum number of matchings. One might assume that the number of these matchings equals the maximum of the degrees of the vertices, and indeed this is the case, but finding such a division can be very challenging.\n\nThere is a well-known algorithm for coloring the edges of a bipartite graph with the minimum number of colors in O(n^3), which I will describe at the end of this tutorial, but first, I will explain what to do if you do not know this algorithm.\n\nLet's try to build the division greedily, choosing the maximum matching each time and removing it. However, not every maximum matching will suit us. For example:\n\nIf we choose the matching [(1,2),(5,4)] in this graph, the remaining edges will have to be divided into two groups.\n\nLet's try to work around this problem. I know at least two ways to do this.\n\nSolution 1\n\nThe first method is as follows: let's try to find a matching that saturates all vertices of maximum degree (so that when it is removed, the maximum degree decreases by 1). This can be done by searching for a flow with a lower bound on some edges. Even if we use the most basic maximum flow algorithm, the solution will work in O(n^4): we will need to find the maximum flow in the network O(n) times, the flow value is O(n) and the number of edges is O(n^2). Using Dinic's algorithm, this can be sped up to O(n^1.13).\n\nHowever, this solution requires quite a bit of code, so I will describe an alternative approach.\n\nSolution 2\n\nAs planned before, we will look for a maximum matching and remove it, but before that, we will transform the graph into a regular bipartite graph (we will add new edges, possibly multiple, so that all vertices' degrees are equal to the maximum).\n\nIn a regular bipartite graph, this greedy approach will actually work: using Hall's theorem, it can be proven that there is always a perfect matching in a regular bipartite graph, and by removing a perfect matching, we reduce the degrees of all vertices (and thus the maximum degree) by 1. This solution will also work in O(n^4).\n\nModel solution\n\nNow let's bring up the edge coloring algorithm for a bipartite graph in O(n^3) — this is the one used in the model solution. We start with a graph that has no edges and will add them one by one while maintaining a correct coloring. We will store the coloring as a matrix color of size n×d, where color[i][j] is −1 if vertex i has no incident edge of color j, or the index of the other end of such an edge if it exists (d is the number of colors we use to color the edges — this is simply the maximum degree of a vertex).\n\nWhen we add an edge (a,b), where a is a vertex in the left part and b is a vertex in the right part, let's find a free color (a color in which no edge incident to the vertex is colored) for each of these vertices. Such a color will always be found because the number of edges incident to a vertex does not exceed d. Let's say we found such a free color ca for vertex a, and cb for vertex b.\n\nIf ca=cb, we can immediately use this color for the edge. Otherwise, let's make color ca for vertex b free.\n\nLet's consider the edges having one of these two colors. Each vertex is incident to at most two such edges, and vertex b is incident to at most one such edge (since color cb is free for this vertex). This means that vertex b is the end of a path consisting of such edges, and the colors of the edges on this path alternate.\n\nWhat will happen if we recolor all edges of color ca on this path to color cb and vice versa? For intermediate vertices, nothing will change. For vertex b, color ca will become free, so we can color the added edge with it. The only vertex for which something might change is the other end of this path; let's call it vertex x. For it, one color was free before, and now another has become free.\n\nBut what if vertex x is vertex a, and we changed an edge of color cb to an edge of color ca, and now we cannot use color ca for it? If the graph was not bipartite, this could indeed happen (which is why this algorithm does not always find the optimal edge coloring for arbitrary graphs), but in a bipartite graph, this is impossible. If we consider the path from b to x, we transition through edges of color ca from the right part to the left, and through edges of color cb from the left to the right. Since vertex a is in the left part, we could only reach it through an edge of color ca—and for vertex a, this color is free, so this is impossible.\n\nThis describes the idea of the algorithm. In the implementation, it is not necessary to explicitly search for a path using something like DFS or BFS; we can simply use a while loop that keeps track of which vertex we are at and which color we need to swap for it.\n\nEach search for such an alternating path works in O(n), and we run it at most O(n^2) times, so the solution works in O(n^3).\n\nIn all three solutions, after dividing the edges into groups, we will also need to complete each group into a Hamiltonian cycle, but this remains as an exercise for the reader (this is one of the simplest parts of the problem).",
    "Solution/Code":"fun main() { val (n, m) = readLine()!!.split(\" \").map { it.toInt() }; val x = IntArray(m); val y = IntArray(m); val edgeId = mutableMapOf<Pair<Int, Int>, Int>(); val inDeg = IntArray(n); val outDeg = IntArray(n); for (i in 0 until m) { val (xi, yi) = readLine()!!.split(\" \").map { it.toInt() }; x[i] = xi - 1; y[i] = yi - 1; edgeId[Pair(x[i], y[i])] = i; inDeg[y[i]]++; outDeg[x[i]]++; } var c = 0; for (i in 0 until n) { c = maxOf(c, inDeg[i], outDeg[i]); } val color = Array(n * 2) { IntArray(c) { -1 } }; for (i in 0 until m) { val a = x[i]; val b = y[i] + n; var ca = 0; while (color[a][ca] != -1) ca++; var cb = 0; while (color[b][cb] != -1) cb++; color[a][ca] = b; color[b][cb] = a; if (ca != cb) { var cur = b; while (cur != -1) { val temp = color[cur][cb]; color[cur][cb] = color[cur][ca]; color[cur][ca] = temp; cur = color[cur][cb]; val tempCa = ca; ca = cb; cb = tempCa; } } } val ans = MutableList(m) { 0 }; for (i in 0 until n) { for (j in 0 until c) { if (color[i][j] != -1) { ans[edgeId[Pair(i, color[i][j] - n)]!!] = j; } } } val xsAdd = mutableListOf<Int>(); val ysAdd = mutableListOf<Int>(); var k = 0; for (i in 0 until c) { val nxt = IntArray(n) { -1 }; val pre = IntArray(n) { -1 }; for (j in 0 until m) { if (ans[j] == i) { nxt[x[j]] = y[j]; pre[y[j]] = x[j]; } } val parts = mutableListOf<Pair<Int, Int>>(); for (j in 0 until n) { if (pre[j] == -1) { var l = j; var r = j; while (nxt[r] != -1) r = nxt[r]; parts.add(Pair(l, r)); } } val p = parts.size; k += p; for (j in 0 until p) { xsAdd.add(parts[j].second); ysAdd.add(parts[(j + 1) % p].first); } for (j in 0 until p) { ans += i; } } println(k); for (i in 0 until k) { println(\"${xsAdd[i] + 1} ${ysAdd[i] + 1}\"); } println(c); for (x in ans) { print(\"${x + 1} \"); } println(); }"

}