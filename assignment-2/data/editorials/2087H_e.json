{
    "Problem Id": "2087H",
    "Tutorial": "To solve this problem, we first need to understand how the values of the Grundy function look for this modification of Nim. Let the value of the Grundy function at x be denoted as G(x). Let the set S consist of numbers s1,s2,…,sk, with s1<s2<⋯<sk. For all numbers from 0 to s1, the Grundy function is equal to the number itself, since the allowed moves for them are the same as in regular Nim. Starting from the value s1+1, the Grundy function will change, but how?\n\nFor the value s1+1, the only possible move leads to the value s1, so G(s1+1)=0 (except when G(s1)=0, in which case G(s1+1)=1). For the value s1+2, there are moves to s1+1 and s1; among the values of the Grundy function for them, there will definitely be 0, and if there is also 1, then G(s1+2)=2, otherwise G(s1+2)=1. And so on; by induction, it can be shown that G(s1+i)=i if G(s1)<i, or G(s1+i)=i−1 otherwise. In other words, in the interval [s1+1,s2], the values of the Grundy function are 0,1,2,…,G(s1)−1,G(s1)+1,G(s1)+2,… The same dependency will hold for the interval [s2+1,s3], and so on.\n\nLet's start by understanding how to find and maintain the Grundy function for the numbers s1,s2,…,sk. For each such number, the value of the Grundy function depends on two parameters: the Grundy function at the previous si and the distance to it. Formally, G(si+1) is computed as follows: if G(si)<|si+1−si|, then G(si+1)=|si+1−si|, otherwise G(si+1)=|si+1−si|−1. Thus, the dependency of G(si+1) on G(si) can be described by something like a ternary operator with three parameters (x,a,b): if the input value is less than x, return a, otherwise return b. In this case, x=|si+1−si|, a=|si+1−si|, b=|si+1−si|−1, and the input value is the previous G(si).\n\nNow let's try to describe the dependency of G(si+2) on G(si). This is a combination of the ternary operator describing the dependency of G(si+1) on G(si) and the ternary operator describing the dependency of G(si+2) on G(si+1). In fact, a combination of two ternary operators of this kind can also be represented as a ternary operator.\n\nThis allows us to build a segment tree for the following operation: on the segment [l,r], combine all the ternary operators describing the dependencies of the Grundy function values for the numbers si∈[l,r] from the previous ones (or from 0 for s1). In the leaves of the segment tree, there will be individual ternary operators for the numbers si (or dummy elements), and in the internal nodes, there will be combinations of the ternary operators from the children. Then, to compute the value of the Grundy function for the number si, a query to the segment tree should form a ternary operator describing the dependency of G(si) on G(0) and provide it with the input 0.\n\nFor a number which is not in S, the Grundy function can be easily computed using the largest value si that does not exceed this number. To avoid handling unnecessary cases, we can also explicitly add 0 to the set S.\n\nWhen adding/removing a number from S, at most two leaves in the segment tree need to be changed, so each query is processed in O(logA) time, where A is the maximum number for which we are interested in the Grundy function. Therefore, the entire solution works in O(A+qlogA) time.",
    "Solution/Code":"import java.util.*\n\ndata class Node(var x: Int = 0, var a: Int = 0, var b: Int = 0)\n\nfun get(n: Node, x: Int): Int {\n    return when {\n        n.x == -1 -> x\n        x < n.x -> n.a\n        else -> n.b\n    }\n}\n\nfun combine(a: Node, b: Node): Node {\n    return when {\n        a.x == -1 -> b\n        b.x == -1 -> a\n        else -> Node(a.x, get(b, a.a), get(b, a.b))\n    }\n}\n\nfun emptyNode(): Node {\n    return Node(-1, -1, -1)\n}\n\nfun fromLength(len: Int): Node {\n    return if (len == -1) emptyNode() else Node(len, len, len - 1)\n}\n\nconst val N = 300003\nconst val M = 300001\n\nval S = sortedSetOf<Int>()\nval T = Array<Node>(4 * N) { emptyNode() }\n\nfun recalc(v: Int) {\n    T[v] = combine(T[v * 2 + 1], T[v * 2 + 2])\n}\n\nfun build(v: Int, l: Int, r: Int) {\n    if (l == r - 1) {\n        T[v] = emptyNode()\n    } else {\n        val m = (l + r) / 2\n        build(v * 2 + 1, l, m)\n        build(v * 2 + 2, m, r)\n        recalc(v)\n    }\n}\n\nfun upd(v: Int, l: Int, r: Int, pos: Int, x: Int) {\n    if (l == r - 1) {\n        T[v] = fromLength(x)\n    } else {\n        val m = (l + r) / 2\n        if (pos < m) upd(v * 2 + 1, l, m, pos, x)\n        else upd(v * 2 + 2, m, r, pos, x)\n        recalc(v)\n    }\n}\n\nfun get(v: Int, l: Int, r: Int, L: Int, R: Int): Node {\n    if (L >= R) return emptyNode()\n    if (L == l && R == r) return T[v]\n    val m = (l + r) / 2\n    return combine(get(v * 2 + 1, l, m, L, minOf(m, R)), get(v * 2 + 2, m, r, maxOf(L, m), R))\n}\n\nfun prepare() {\n    build(0, 0, M)\n    upd(0, 0, M, 0, 0)\n    S.add(0)\n}\n\nfun insertValue(x: Int) {\n    val it = S.ceiling(x)\n    if (it != null) {\n        upd(0, 0, M, it, it - x)\n    }\n    S.lower(x)?.let { upd(0, 0, M, x, x - it) }\n    S.add(x)\n}\n\nfun eraseValue(x: Int) {\n    upd(0, 0, M, x, -1)\n    S.remove(x)\n    val it = S.ceiling(x)\n    if (it != null) {\n        val y = it\n        S.lower(y)?.let { upd(0, 0, M, y, y - it) }\n    }\n}\n\nfun getGrundy(x: Int): Int {\n    val n = get(0, 0, M, 0, x)\n    val it = S.lower(x)\n    val y = it ?: return x\n    val valY = get(n, 0)\n    val dist = x - y\n    return if (dist <= valY) dist - 1 else dist\n}\n\nfun main() {\n    val q = readln().toInt()\n\n    prepare()\n    println((0 until q).map {\n        val params = readln().split(\" \").map { it.toInt() }\n        val (t, x) = params.take(2)\n        if (t == 1) {\n            if (S.contains(x)) eraseValue(x) else insertValue(x)\n            null\n        } else {\n            val res = params.drop(2).fold(0) { r, y -> r xor getGrundy(y) }\n            if (res == 0) \"Second\" else \"First\"\n        }\n    }.filterNotNull().joinToString(\"\\n\"))\n}"

}