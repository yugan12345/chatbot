{
    "Problem Id": "2087E",
    "Tutorial": "In an ideal case, the answer includes all arrows with a positive cost. Why can't this always be achieved? This is quite evident in the test case \"<<<>>>\". It cannot be the case that the leftmost repainted arrow points to the left while the rightmost one points to the right. But what if this condition is not only necessary but also sufficient? Let's constructively show that this is indeed the case. Suppose we want to repaint a set such that the leftmost arrow points to the right. Then the process goes as follows. We start with the rightmost arrow pointing to the left. We repaint all arrows pointing to the left, moving from right to left. Then we repaint the leftmost arrow (pointing to the right). After that, we repaint all arrows pointing to the right, moving from left to right. The case where the rightmost arrow points to the left is handled similarly. Thus, we need to find the best answer of the following form: the leftmost arrow points to the right or the rightmost arrow points to the left. We can consider this as two independent cases and take the maximum of their answers. Fix the leftmost arrow. It must point to the right. Then, we can take any arrows to its right, and the answer will already be valid. We take all arrows with a positive cost. Note that the leftmost arrow can be negative even in the optimal answer. Overall complexity: O(n) per test case.",
    "Solution/Code":"fun main() = repeat(readLine()!!.toInt()) {\n    val n = readLine()!!.toInt()\n    var s = readLine()!!\n    var a = readLine()!!.split(\" \").map { it.toInt() }\n    \n    var ans = 0.toLong()\n    \n    repeat(2) {\n        var sum = 0.toLong()\n        for (i in 0 until n) {\n            if (s[i] == '<')\n                ans = maxOf(ans, sum + a[i])\n            sum += maxOf(a[i], 0)\n        }\n        a = a.reversed()\n        s = s.reversed().replace('<', '.').replace('>', '<').replace('.', '>')\n    }\n    \n    println(ans)\n}"

}