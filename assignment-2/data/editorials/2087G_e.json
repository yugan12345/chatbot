{
    "Problem Id": "2087G",
    "Tutorial":"To calculate how much Monocarp will earn in exactly k training days, we first compute total earnings by treating competition and training days differently. For a competition day, we add ai to the total; for a training day at index i, we add (n−i−1) minus the number of future training days. This simplifies to subtracting k(k−1)/2 from total earnings. Next, construct an array d where di = n−i−1−ai. To maximize earnings, select the k largest values from d. Sort d in descending order, then sum the first k elements to find the maximum possible additional gain. For counting the number of ways to achieve this sum for each k, maintain indices l and r where l is the first occurrence of dl ≤ dk−1 and r is the first occurrence of dr < dk−1. The number of ways to choose the necessary elements from di=dk−1 within [l,r) is C(r−l,k−l). Iterate through all possible k, precomputing factorials and inverse factorials modulo mod for efficient binomial coefficient calculation. The solution has O(n log n) time complexity and O(n) space complexity.",
    "Solution/Code":"fun main() {\n    data class ModInt(val value : Int = 0) {\n        val MOD = 998244353\n        operator fun plus(oth : ModInt) : ModInt {\n            val cur = (this.value + oth.value) % MOD\n            return ModInt(cur)\n        }\n        operator fun times(oth : ModInt) : ModInt {\n            val cur = value.toLong() * oth.value % MOD\n            return ModInt(cur.toInt())\n        }\n        fun pow(k: Int) : ModInt {\n            var ans = ModInt(1)\n            var a = ModInt(value)\n            var curPw = k\n            while (curPw > 0) {\n                if (curPw % 2 == 1)\n                    ans *= a\n                a *= a\n                curPw /= 2\n            }\n            return ans\n        }\n        fun inverse() = this.pow(MOD - 2)\n        override fun toString() = this.value.toString()\n    }\n\n    val n = readln().toInt()\n    val a = readln().split(\" \").map { it.toInt() }\n\n    val factorials = (1..n).runningFold(ModInt(1)) { acc, it -> acc * ModInt(it) }\n    val invFact = factorials.map { it.inverse() }\n\n    fun choose(n : Int, k : Int) : ModInt {\n        if (k < 0 || n < k)\n            return ModInt(0)\n        return factorials[n] * invFact[k] * invFact[n - k]\n    }\n\n    val sum = a.sumOf { it.toLong() }\n    val delta = List(n) { n - it - 1 - a[it] }.sortedDescending()\n\n    var ansVal = sum\n    var ansCnt = ModInt(1)\n\n    var curSum = 0L\n    var lf = 0\n    var rg = 0\n    for (k in 1..n) {\n        curSum += delta[k - 1]\n        while (delta[lf] > delta[k - 1])\n            lf++\n        while (rg < delta.size && delta[rg] >= delta[k - 1])\n            rg++\n        val curVal = sum + curSum - k.toLong() * (k - 1) / 2\n        val curCnt = choose(rg - lf, k - lf)\n        if (ansVal < curVal) {\n            ansVal = curVal\n            ansCnt = ModInt(0)\n        }\n        if (ansVal == curVal) {\n            ansCnt += curCnt\n        }\n    }\n    println(\"$ansVal $ansCnt\")\n}"

}