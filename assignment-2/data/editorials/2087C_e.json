{
    "Problem Id": "2087C",
    "Tutorial": "The key observation is that the player always picks the type of coin with the highest frequency of occurrence. This fact allows us to clearly see how the game is played. Let x, y, and z be the number of gold, silver, and bronze coins, respectively. The first player takes the maximum among these three numbers. Then the second player takes the second maximum. Finally, the first player takes the third maximum. So, the solution is to calculate the number of coins of each type. The number of coins the first player can collect is the maximum plus the minimum among these calculated values. To calculate the number of occurrences of each type quickly, you can use prefix sums: for each type of coins, let's form an array where the element on the i-th position is equal to the number of coins having that type among the first i coins. Then, the number of coins of a specific type in a segment can be computed quickly by subtracting the value for the left boundary from the value for the right boundary.",
    "Solution/Code":"const val coins = \"BSG\"\n\nfun main() {\n  val s = readln()\n  val sum = Array(3) { \n    s.map { c -> if (c == coins[it]) 1 else 0 }\n     .scan(0) { x, y -> x + y }\n  }\n  \n  val q = readln().toInt()\n  println((0 until q).map {\n    val (l, r) = readln().split(\" \").map { it.toInt() }\n    val cnt = sum.map { it[r] - it[l - 1] }\n    cnt.max() + cnt.min()\n  }.joinToString(\"\\n\"))\n}"

}